// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod fb {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum AccountOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Account<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Account<'a> {
  type Inner = Account<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Account<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_BALANCE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Account { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AccountArgs<'args>
  ) -> flatbuffers::WIPOffset<Account<'bldr>> {
    let mut builder = AccountBuilder::new(_fbb);
    builder.add_balance(args.balance);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Account::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Account::VT_NAME, None)}
  }
  #[inline]
  pub fn balance(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Account::VT_BALANCE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Account<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct AccountArgs<'a> {
    pub id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub balance: u64,
}
impl<'a> Default for AccountArgs<'a> {
  #[inline]
  fn default() -> Self {
    AccountArgs {
      id: 0,
      name: None,
      balance: 0,
    }
  }
}

pub struct AccountBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AccountBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Account::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Account::VT_NAME, name);
  }
  #[inline]
  pub fn add_balance(&mut self, balance: u64) {
    self.fbb_.push_slot::<u64>(Account::VT_BALANCE, balance, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AccountBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AccountBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Account<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Account<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Account");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("balance", &self.balance());
      ds.finish()
  }
}
pub enum AccountVecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AccountVec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AccountVec<'a> {
  type Inner = AccountVec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AccountVec<'a> {
  pub const VT_ACCOUNTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AccountVec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AccountVecArgs<'args>
  ) -> flatbuffers::WIPOffset<AccountVec<'bldr>> {
    let mut builder = AccountVecBuilder::new(_fbb);
    if let Some(x) = args.accounts { builder.add_accounts(x); }
    builder.finish()
  }


  #[inline]
  pub fn accounts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account>>>>(AccountVec::VT_ACCOUNTS, None)}
  }
}

impl flatbuffers::Verifiable for AccountVec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Account>>>>("accounts", Self::VT_ACCOUNTS, false)?
     .finish();
    Ok(())
  }
}
pub struct AccountVecArgs<'a> {
    pub accounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account<'a>>>>>,
}
impl<'a> Default for AccountVecArgs<'a> {
  #[inline]
  fn default() -> Self {
    AccountVecArgs {
      accounts: None,
    }
  }
}

pub struct AccountVecBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AccountVecBuilder<'a, 'b> {
  #[inline]
  pub fn add_accounts(&mut self, accounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Account<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AccountVec::VT_ACCOUNTS, accounts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AccountVecBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AccountVecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AccountVec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AccountVec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AccountVec");
      ds.field("accounts", &self.accounts());
      ds.finish()
  }
}
pub enum BalanceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Balance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Balance<'a> {
  type Inner = Balance<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Balance<'a> {
  pub const VT_SHIELDED: flatbuffers::VOffsetT = 4;
  pub const VT_UNCONFIRMED_SPENT: flatbuffers::VOffsetT = 6;
  pub const VT_BALANCE: flatbuffers::VOffsetT = 8;
  pub const VT_UNDER_CONFIRMED: flatbuffers::VOffsetT = 10;
  pub const VT_EXCLUDED: flatbuffers::VOffsetT = 12;
  pub const VT_SAPLING: flatbuffers::VOffsetT = 14;
  pub const VT_ORCHARD: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Balance { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BalanceArgs
  ) -> flatbuffers::WIPOffset<Balance<'bldr>> {
    let mut builder = BalanceBuilder::new(_fbb);
    builder.add_orchard(args.orchard);
    builder.add_sapling(args.sapling);
    builder.add_excluded(args.excluded);
    builder.add_under_confirmed(args.under_confirmed);
    builder.add_balance(args.balance);
    builder.add_unconfirmed_spent(args.unconfirmed_spent);
    builder.add_shielded(args.shielded);
    builder.finish()
  }


  #[inline]
  pub fn shielded(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Balance::VT_SHIELDED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unconfirmed_spent(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Balance::VT_UNCONFIRMED_SPENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn balance(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Balance::VT_BALANCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn under_confirmed(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Balance::VT_UNDER_CONFIRMED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn excluded(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Balance::VT_EXCLUDED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sapling(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Balance::VT_SAPLING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn orchard(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Balance::VT_ORCHARD, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Balance<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("shielded", Self::VT_SHIELDED, false)?
     .visit_field::<u64>("unconfirmed_spent", Self::VT_UNCONFIRMED_SPENT, false)?
     .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
     .visit_field::<u64>("under_confirmed", Self::VT_UNDER_CONFIRMED, false)?
     .visit_field::<u64>("excluded", Self::VT_EXCLUDED, false)?
     .visit_field::<u64>("sapling", Self::VT_SAPLING, false)?
     .visit_field::<u64>("orchard", Self::VT_ORCHARD, false)?
     .finish();
    Ok(())
  }
}
pub struct BalanceArgs {
    pub shielded: u64,
    pub unconfirmed_spent: u64,
    pub balance: u64,
    pub under_confirmed: u64,
    pub excluded: u64,
    pub sapling: u64,
    pub orchard: u64,
}
impl<'a> Default for BalanceArgs {
  #[inline]
  fn default() -> Self {
    BalanceArgs {
      shielded: 0,
      unconfirmed_spent: 0,
      balance: 0,
      under_confirmed: 0,
      excluded: 0,
      sapling: 0,
      orchard: 0,
    }
  }
}

pub struct BalanceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BalanceBuilder<'a, 'b> {
  #[inline]
  pub fn add_shielded(&mut self, shielded: u64) {
    self.fbb_.push_slot::<u64>(Balance::VT_SHIELDED, shielded, 0);
  }
  #[inline]
  pub fn add_unconfirmed_spent(&mut self, unconfirmed_spent: u64) {
    self.fbb_.push_slot::<u64>(Balance::VT_UNCONFIRMED_SPENT, unconfirmed_spent, 0);
  }
  #[inline]
  pub fn add_balance(&mut self, balance: u64) {
    self.fbb_.push_slot::<u64>(Balance::VT_BALANCE, balance, 0);
  }
  #[inline]
  pub fn add_under_confirmed(&mut self, under_confirmed: u64) {
    self.fbb_.push_slot::<u64>(Balance::VT_UNDER_CONFIRMED, under_confirmed, 0);
  }
  #[inline]
  pub fn add_excluded(&mut self, excluded: u64) {
    self.fbb_.push_slot::<u64>(Balance::VT_EXCLUDED, excluded, 0);
  }
  #[inline]
  pub fn add_sapling(&mut self, sapling: u64) {
    self.fbb_.push_slot::<u64>(Balance::VT_SAPLING, sapling, 0);
  }
  #[inline]
  pub fn add_orchard(&mut self, orchard: u64) {
    self.fbb_.push_slot::<u64>(Balance::VT_ORCHARD, orchard, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BalanceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BalanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Balance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Balance<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Balance");
      ds.field("shielded", &self.shielded());
      ds.field("unconfirmed_spent", &self.unconfirmed_spent());
      ds.field("balance", &self.balance());
      ds.field("under_confirmed", &self.under_confirmed());
      ds.field("excluded", &self.excluded());
      ds.field("sapling", &self.sapling());
      ds.field("orchard", &self.orchard());
      ds.finish()
  }
}
pub enum HeightOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Height<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Height<'a> {
  type Inner = Height<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Height<'a> {
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Height { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HeightArgs
  ) -> flatbuffers::WIPOffset<Height<'bldr>> {
    let mut builder = HeightBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    builder.add_height(args.height);
    builder.finish()
  }


  #[inline]
  pub fn height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Height::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Height::VT_TIMESTAMP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Height<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct HeightArgs {
    pub height: u32,
    pub timestamp: u32,
}
impl<'a> Default for HeightArgs {
  #[inline]
  fn default() -> Self {
    HeightArgs {
      height: 0,
      timestamp: 0,
    }
  }
}

pub struct HeightBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeightBuilder<'a, 'b> {
  #[inline]
  pub fn add_height(&mut self, height: u32) {
    self.fbb_.push_slot::<u32>(Height::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u32) {
    self.fbb_.push_slot::<u32>(Height::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeightBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeightBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Height<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Height<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Height");
      ds.field("height", &self.height());
      ds.field("timestamp", &self.timestamp());
      ds.finish()
  }
}
pub enum ShieldedNoteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShieldedNote<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShieldedNote<'a> {
  type Inner = ShieldedNote<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ShieldedNote<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
  pub const VT_ORCHARD: flatbuffers::VOffsetT = 12;
  pub const VT_EXCLUDED: flatbuffers::VOffsetT = 14;
  pub const VT_SPENT: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShieldedNote { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ShieldedNoteArgs
  ) -> flatbuffers::WIPOffset<ShieldedNote<'bldr>> {
    let mut builder = ShieldedNoteBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.add_timestamp(args.timestamp);
    builder.add_height(args.height);
    builder.add_id(args.id);
    builder.add_spent(args.spent);
    builder.add_excluded(args.excluded);
    builder.add_orchard(args.orchard);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedNote::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedNote::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ShieldedNote::VT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedNote::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn orchard(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShieldedNote::VT_ORCHARD, Some(false)).unwrap()}
  }
  #[inline]
  pub fn excluded(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShieldedNote::VT_EXCLUDED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn spent(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShieldedNote::VT_SPENT, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ShieldedNote<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<u64>("value", Self::VT_VALUE, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<bool>("orchard", Self::VT_ORCHARD, false)?
     .visit_field::<bool>("excluded", Self::VT_EXCLUDED, false)?
     .visit_field::<bool>("spent", Self::VT_SPENT, false)?
     .finish();
    Ok(())
  }
}
pub struct ShieldedNoteArgs {
    pub id: u32,
    pub height: u32,
    pub value: u64,
    pub timestamp: u32,
    pub orchard: bool,
    pub excluded: bool,
    pub spent: bool,
}
impl<'a> Default for ShieldedNoteArgs {
  #[inline]
  fn default() -> Self {
    ShieldedNoteArgs {
      id: 0,
      height: 0,
      value: 0,
      timestamp: 0,
      orchard: false,
      excluded: false,
      spent: false,
    }
  }
}

pub struct ShieldedNoteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShieldedNoteBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(ShieldedNote::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_height(&mut self, height: u32) {
    self.fbb_.push_slot::<u32>(ShieldedNote::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(ShieldedNote::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u32) {
    self.fbb_.push_slot::<u32>(ShieldedNote::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_orchard(&mut self, orchard: bool) {
    self.fbb_.push_slot::<bool>(ShieldedNote::VT_ORCHARD, orchard, false);
  }
  #[inline]
  pub fn add_excluded(&mut self, excluded: bool) {
    self.fbb_.push_slot::<bool>(ShieldedNote::VT_EXCLUDED, excluded, false);
  }
  #[inline]
  pub fn add_spent(&mut self, spent: bool) {
    self.fbb_.push_slot::<bool>(ShieldedNote::VT_SPENT, spent, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShieldedNoteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShieldedNoteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedNote<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShieldedNote<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShieldedNote");
      ds.field("id", &self.id());
      ds.field("height", &self.height());
      ds.field("value", &self.value());
      ds.field("timestamp", &self.timestamp());
      ds.field("orchard", &self.orchard());
      ds.field("excluded", &self.excluded());
      ds.field("spent", &self.spent());
      ds.finish()
  }
}
pub enum ShieldedNoteVecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShieldedNoteVec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShieldedNoteVec<'a> {
  type Inner = ShieldedNoteVec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ShieldedNoteVec<'a> {
  pub const VT_NOTES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShieldedNoteVec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ShieldedNoteVecArgs<'args>
  ) -> flatbuffers::WIPOffset<ShieldedNoteVec<'bldr>> {
    let mut builder = ShieldedNoteVecBuilder::new(_fbb);
    if let Some(x) = args.notes { builder.add_notes(x); }
    builder.finish()
  }


  #[inline]
  pub fn notes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote>>>>(ShieldedNoteVec::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for ShieldedNoteVec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ShieldedNote>>>>("notes", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct ShieldedNoteVecArgs<'a> {
    pub notes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote<'a>>>>>,
}
impl<'a> Default for ShieldedNoteVecArgs<'a> {
  #[inline]
  fn default() -> Self {
    ShieldedNoteVecArgs {
      notes: None,
    }
  }
}

pub struct ShieldedNoteVecBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShieldedNoteVecBuilder<'a, 'b> {
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ShieldedNote<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedNoteVec::VT_NOTES, notes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShieldedNoteVecBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShieldedNoteVecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedNoteVec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShieldedNoteVec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShieldedNoteVec");
      ds.field("notes", &self.notes());
      ds.finish()
  }
}
pub enum AdressbookEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AdressbookEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AdressbookEntry<'a> {
  type Inner = AdressbookEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AdressbookEntry<'a> {
  pub const VT_ID_ADDRESS: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AdressbookEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AdressbookEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<AdressbookEntry<'bldr>> {
    let mut builder = AdressbookEntryBuilder::new(_fbb);
    if let Some(x) = args.address { builder.add_address(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_id_address(args.id_address);
    builder.finish()
  }


  #[inline]
  pub fn id_address(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(AdressbookEntry::VT_ID_ADDRESS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AdressbookEntry::VT_NAME, None)}
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AdressbookEntry::VT_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for AdressbookEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id_address", Self::VT_ID_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct AdressbookEntryArgs<'a> {
    pub id_address: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AdressbookEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    AdressbookEntryArgs {
      id_address: 0,
      name: None,
      address: None,
    }
  }
}

pub struct AdressbookEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AdressbookEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_id_address(&mut self, id_address: u32) {
    self.fbb_.push_slot::<u32>(AdressbookEntry::VT_ID_ADDRESS, id_address, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AdressbookEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AdressbookEntry::VT_ADDRESS, address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AdressbookEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AdressbookEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AdressbookEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AdressbookEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AdressbookEntry");
      ds.field("id_address", &self.id_address());
      ds.field("name", &self.name());
      ds.field("address", &self.address());
      ds.finish()
  }
}
pub enum AddressbookOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Addressbook<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Addressbook<'a> {
  type Inner = Addressbook<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Addressbook<'a> {
  pub const VT_ACCOUNTS: flatbuffers::VOffsetT = 4;
  pub const VT_CONTACTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Addressbook { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AddressbookArgs<'args>
  ) -> flatbuffers::WIPOffset<Addressbook<'bldr>> {
    let mut builder = AddressbookBuilder::new(_fbb);
    if let Some(x) = args.contacts { builder.add_contacts(x); }
    if let Some(x) = args.accounts { builder.add_accounts(x); }
    builder.finish()
  }


  #[inline]
  pub fn accounts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdressbookEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdressbookEntry>>>>(Addressbook::VT_ACCOUNTS, None)}
  }
  #[inline]
  pub fn contacts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdressbookEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdressbookEntry>>>>(Addressbook::VT_CONTACTS, None)}
  }
}

impl flatbuffers::Verifiable for Addressbook<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AdressbookEntry>>>>("accounts", Self::VT_ACCOUNTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AdressbookEntry>>>>("contacts", Self::VT_CONTACTS, false)?
     .finish();
    Ok(())
  }
}
pub struct AddressbookArgs<'a> {
    pub accounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdressbookEntry<'a>>>>>,
    pub contacts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdressbookEntry<'a>>>>>,
}
impl<'a> Default for AddressbookArgs<'a> {
  #[inline]
  fn default() -> Self {
    AddressbookArgs {
      accounts: None,
      contacts: None,
    }
  }
}

pub struct AddressbookBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddressbookBuilder<'a, 'b> {
  #[inline]
  pub fn add_accounts(&mut self, accounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AdressbookEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Addressbook::VT_ACCOUNTS, accounts);
  }
  #[inline]
  pub fn add_contacts(&mut self, contacts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AdressbookEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Addressbook::VT_CONTACTS, contacts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddressbookBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddressbookBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Addressbook<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Addressbook<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Addressbook");
      ds.field("accounts", &self.accounts());
      ds.field("contacts", &self.contacts());
      ds.finish()
  }
}
pub enum AccountBalanceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AccountBalance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AccountBalance<'a> {
  type Inner = AccountBalance<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AccountBalance<'a> {
  pub const VT_COIN: flatbuffers::VOffsetT = 4;
  pub const VT_ID_ACCOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_BALANCE: flatbuffers::VOffsetT = 10;
  pub const VT_TBALANCE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AccountBalance { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AccountBalanceArgs<'args>
  ) -> flatbuffers::WIPOffset<AccountBalance<'bldr>> {
    let mut builder = AccountBalanceBuilder::new(_fbb);
    builder.add_tbalance(args.tbalance);
    builder.add_balance(args.balance);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_id_account(args.id_account);
    builder.add_coin(args.coin);
    builder.finish()
  }


  #[inline]
  pub fn coin(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(AccountBalance::VT_COIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id_account(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(AccountBalance::VT_ID_ACCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AccountBalance::VT_NAME, None)}
  }
  #[inline]
  pub fn balance(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(AccountBalance::VT_BALANCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn tbalance(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(AccountBalance::VT_TBALANCE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AccountBalance<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("coin", Self::VT_COIN, false)?
     .visit_field::<u32>("id_account", Self::VT_ID_ACCOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
     .visit_field::<u64>("tbalance", Self::VT_TBALANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct AccountBalanceArgs<'a> {
    pub coin: u8,
    pub id_account: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub balance: u64,
    pub tbalance: u64,
}
impl<'a> Default for AccountBalanceArgs<'a> {
  #[inline]
  fn default() -> Self {
    AccountBalanceArgs {
      coin: 0,
      id_account: 0,
      name: None,
      balance: 0,
      tbalance: 0,
    }
  }
}

pub struct AccountBalanceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AccountBalanceBuilder<'a, 'b> {
  #[inline]
  pub fn add_coin(&mut self, coin: u8) {
    self.fbb_.push_slot::<u8>(AccountBalance::VT_COIN, coin, 0);
  }
  #[inline]
  pub fn add_id_account(&mut self, id_account: u32) {
    self.fbb_.push_slot::<u32>(AccountBalance::VT_ID_ACCOUNT, id_account, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AccountBalance::VT_NAME, name);
  }
  #[inline]
  pub fn add_balance(&mut self, balance: u64) {
    self.fbb_.push_slot::<u64>(AccountBalance::VT_BALANCE, balance, 0);
  }
  #[inline]
  pub fn add_tbalance(&mut self, tbalance: u64) {
    self.fbb_.push_slot::<u64>(AccountBalance::VT_TBALANCE, tbalance, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AccountBalanceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AccountBalanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AccountBalance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AccountBalance<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AccountBalance");
      ds.field("coin", &self.coin());
      ds.field("id_account", &self.id_account());
      ds.field("name", &self.name());
      ds.field("balance", &self.balance());
      ds.field("tbalance", &self.tbalance());
      ds.finish()
  }
}
pub enum AccountBalancesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AccountBalances<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AccountBalances<'a> {
  type Inner = AccountBalances<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AccountBalances<'a> {
  pub const VT_ACCOUNTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AccountBalances { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AccountBalancesArgs<'args>
  ) -> flatbuffers::WIPOffset<AccountBalances<'bldr>> {
    let mut builder = AccountBalancesBuilder::new(_fbb);
    if let Some(x) = args.accounts { builder.add_accounts(x); }
    builder.finish()
  }


  #[inline]
  pub fn accounts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AccountBalance<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AccountBalance>>>>(AccountBalances::VT_ACCOUNTS, None)}
  }
}

impl flatbuffers::Verifiable for AccountBalances<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AccountBalance>>>>("accounts", Self::VT_ACCOUNTS, false)?
     .finish();
    Ok(())
  }
}
pub struct AccountBalancesArgs<'a> {
    pub accounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AccountBalance<'a>>>>>,
}
impl<'a> Default for AccountBalancesArgs<'a> {
  #[inline]
  fn default() -> Self {
    AccountBalancesArgs {
      accounts: None,
    }
  }
}

pub struct AccountBalancesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AccountBalancesBuilder<'a, 'b> {
  #[inline]
  pub fn add_accounts(&mut self, accounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AccountBalance<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AccountBalances::VT_ACCOUNTS, accounts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AccountBalancesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AccountBalancesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AccountBalances<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AccountBalances<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AccountBalances");
      ds.field("accounts", &self.accounts());
      ds.finish()
  }
}
pub enum ZMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZMessage<'a> {
  type Inner = ZMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZMessage<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TX_ID: flatbuffers::VOffsetT = 6;
  pub const VT_INCOMING: flatbuffers::VOffsetT = 8;
  pub const VT_SENDER: flatbuffers::VOffsetT = 10;
  pub const VT_RECIPIENT: flatbuffers::VOffsetT = 12;
  pub const VT_SUBJECT: flatbuffers::VOffsetT = 14;
  pub const VT_BODY: flatbuffers::VOffsetT = 16;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 18;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 20;
  pub const VT_READ: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ZMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<ZMessage<'bldr>> {
    let mut builder = ZMessageBuilder::new(_fbb);
    builder.add_height(args.height);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.subject { builder.add_subject(x); }
    if let Some(x) = args.recipient { builder.add_recipient(x); }
    if let Some(x) = args.sender { builder.add_sender(x); }
    builder.add_tx_id(args.tx_id);
    builder.add_id(args.id);
    builder.add_read(args.read);
    builder.add_incoming(args.incoming);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ZMessage::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn tx_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ZMessage::VT_TX_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn incoming(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ZMessage::VT_INCOMING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn sender(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZMessage::VT_SENDER, None)}
  }
  #[inline]
  pub fn recipient(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZMessage::VT_RECIPIENT, None)}
  }
  #[inline]
  pub fn subject(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZMessage::VT_SUBJECT, None)}
  }
  #[inline]
  pub fn body(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZMessage::VT_BODY, None)}
  }
  #[inline]
  pub fn timestamp(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ZMessage::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ZMessage::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn read(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ZMessage::VT_READ, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ZMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<u32>("tx_id", Self::VT_TX_ID, false)?
     .visit_field::<bool>("incoming", Self::VT_INCOMING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender", Self::VT_SENDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient", Self::VT_RECIPIENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subject", Self::VT_SUBJECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<bool>("read", Self::VT_READ, false)?
     .finish();
    Ok(())
  }
}
pub struct ZMessageArgs<'a> {
    pub id: u32,
    pub tx_id: u32,
    pub incoming: bool,
    pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u32,
    pub height: u32,
    pub read: bool,
}
impl<'a> Default for ZMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    ZMessageArgs {
      id: 0,
      tx_id: 0,
      incoming: false,
      sender: None,
      recipient: None,
      subject: None,
      body: None,
      timestamp: 0,
      height: 0,
      read: false,
    }
  }
}

pub struct ZMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ZMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(ZMessage::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_tx_id(&mut self, tx_id: u32) {
    self.fbb_.push_slot::<u32>(ZMessage::VT_TX_ID, tx_id, 0);
  }
  #[inline]
  pub fn add_incoming(&mut self, incoming: bool) {
    self.fbb_.push_slot::<bool>(ZMessage::VT_INCOMING, incoming, false);
  }
  #[inline]
  pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZMessage::VT_SENDER, sender);
  }
  #[inline]
  pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZMessage::VT_RECIPIENT, recipient);
  }
  #[inline]
  pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZMessage::VT_SUBJECT, subject);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZMessage::VT_BODY, body);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u32) {
    self.fbb_.push_slot::<u32>(ZMessage::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_height(&mut self, height: u32) {
    self.fbb_.push_slot::<u32>(ZMessage::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_read(&mut self, read: bool) {
    self.fbb_.push_slot::<bool>(ZMessage::VT_READ, read, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ZMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ZMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZMessage");
      ds.field("id", &self.id());
      ds.field("tx_id", &self.tx_id());
      ds.field("incoming", &self.incoming());
      ds.field("sender", &self.sender());
      ds.field("recipient", &self.recipient());
      ds.field("subject", &self.subject());
      ds.field("body", &self.body());
      ds.field("timestamp", &self.timestamp());
      ds.field("height", &self.height());
      ds.field("read", &self.read());
      ds.finish()
  }
}
pub enum ZMessagesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZMessages<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZMessages<'a> {
  type Inner = ZMessages<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZMessages<'a> {
  pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZMessages { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ZMessagesArgs<'args>
  ) -> flatbuffers::WIPOffset<ZMessages<'bldr>> {
    let mut builder = ZMessagesBuilder::new(_fbb);
    if let Some(x) = args.messages { builder.add_messages(x); }
    builder.finish()
  }


  #[inline]
  pub fn messages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ZMessage<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ZMessage>>>>(ZMessages::VT_MESSAGES, None)}
  }
}

impl flatbuffers::Verifiable for ZMessages<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ZMessage>>>>("messages", Self::VT_MESSAGES, false)?
     .finish();
    Ok(())
  }
}
pub struct ZMessagesArgs<'a> {
    pub messages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ZMessage<'a>>>>>,
}
impl<'a> Default for ZMessagesArgs<'a> {
  #[inline]
  fn default() -> Self {
    ZMessagesArgs {
      messages: None,
    }
  }
}

pub struct ZMessagesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ZMessagesBuilder<'a, 'b> {
  #[inline]
  pub fn add_messages(&mut self, messages: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ZMessage<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZMessages::VT_MESSAGES, messages);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ZMessagesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ZMessagesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZMessages<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZMessages<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZMessages");
      ds.field("messages", &self.messages());
      ds.finish()
  }
}
}  // pub mod fb

